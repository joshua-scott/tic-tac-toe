{"version":3,"sources":["app.js","cpu.js"],"names":["cells","document","querySelectorAll","wins","movesMade","makeMove","isEmpty","dataset","index","stopClicks","textContent","classList","add","isGameOver","setTimeout","cpuMove","allowClicks","lastPlayer","checkForWinner","gameOver","checkForDraw","board","buildBoard","result","forEach","win","threeInARow","c","push","first","second","third","b","winner","alert","newGame","remove","addEventListener","removeEventListener","winOrBlock","goInCentre","coverOppositeCorners","coverAdjoiningEdges","offensiveMove","goInRemaining","which","letter","twos","filter","isPotentialLineForming","length","markOneOfThese","shuffle","pop","winningPattern","blanksRequired","blanks","letters","i","cellContents","markCell","oppositeCornerDanger","middleEdges","blankCorners","opponentCorners","corners","corner","dangerousCorner","checkHorizontally","checkVertically","cell1","cell2","oneEmptyOneX","moves","remaining","potentialMoves","arr","sort","Math","random"],"mappings":"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","file":"app.js","sourcesContent":["const cells = document.querySelectorAll('.cell');\r\n\r\nconst wins = [\r\n  [0,1,2], [3,4,5], [6,7,8],  // horizontal\r\n  [0,3,6], [1,4,7], [2,5,8],  // vertical\r\n  [0,4,8], [2,4,6]            // diagonal\r\n];\r\n\r\nlet movesMade = 0;\r\n\r\nfunction makeMove() {\r\n  if (!isEmpty(this.dataset.index)) return;\r\n\r\n  stopClicks();\r\n\r\n  this.textContent = 'X';\r\n  this.classList.add('blue');\r\n  movesMade++;\r\n  \r\n  if (isGameOver('Player')) return;\r\n\r\n  // Allow a little time for DOM to update (and simulate 'thinking')\r\n  setTimeout(() => {\r\n    cpuMove();\r\n    if (!isGameOver('CPU')) allowClicks();\r\n  }, 500);\r\n}\r\n\r\nfunction isGameOver(lastPlayer) {\r\n  if (checkForWinner()) {\r\n    gameOver(lastPlayer);\r\n    return true;\r\n  } else if (checkForDraw()) {\r\n    gameOver('Draw');\r\n    return true;\r\n  } else {\r\n    return false;\r\n  }\r\n}\r\n\r\nfunction checkForWinner() {\r\n  const board = buildBoard();\r\n  \r\n  // Check the board against 'wins' array\r\n  let result = false;\r\n  wins.forEach(win => {\r\n    if (threeInARow(board, ...win)) {\r\n      result = true;\r\n    }\r\n  });\r\n  return result;\r\n}\r\n\r\n// Build array to represent the board\r\nfunction buildBoard() {\r\n  const board = [];\r\n  cells.forEach(c => board.push(c.textContent));\r\n  return board;\r\n}\r\n\r\nfunction checkForDraw() {\r\n  return (movesMade >= 9);\r\n}\r\n\r\nfunction isEmpty(index) {\r\n  return cells[index].textContent === '';\r\n}\r\n\r\nfunction threeInARow(board, first, second, third) {\r\n  const b = board;\r\n  return (b[first] !== '' && b[first] === b[second] && b[second] === b[third]);\r\n}\r\n\r\nfunction gameOver(winner) {\r\n  // Allow a little time for DOM to update\r\n  setTimeout(() => {\r\n    winner === 'Draw' ? alert(`It's a draw!`) : alert(`${winner} wins!`);\r\n    newGame();\r\n  }, 15);\r\n}\r\n\r\nfunction newGame() {\r\n  movesMade = 0;\r\n  cells.forEach(c => {\r\n    c.classList.remove('blue', 'red');\r\n    c.textContent = '';\r\n  });\r\n  // Refreshing the clicks like this fixes a pesky bug where sometimes no clicks are allowed\r\n  stopClicks();\r\n  allowClicks();\r\n}\r\n\r\nfunction allowClicks() {\r\n  cells.forEach(c => c.addEventListener('click', makeMove));\r\n}\r\n\r\nfunction stopClicks() {\r\n  cells.forEach(c => c.removeEventListener('click', makeMove));\r\n}\r\n\r\nallowClicks();","function cpuMove() {\r\n  movesMade++;\r\n\r\n  if (winOrBlock('win')) return;\r\n  else if (winOrBlock('block')) return;\r\n  else if (goInCentre()) return;\r\n  else if (coverOppositeCorners()) return;\r\n  else if (coverAdjoiningEdges()) return;\r\n  else if (offensiveMove()) return;\r\n  else goInRemaining();\r\n}\r\n\r\nfunction winOrBlock(which) {\r\n  const letter = which === 'win' ? 'O' : 'X';\r\n  // Look for 2 in a row, where we can win or block a win\r\n  const board = buildBoard();\r\n  const twos = wins.filter(win => isPotentialLineForming(board, win, letter, 1));\r\n\r\n  if (twos.length === 0) {\r\n    // We can't win/block on this turn\r\n    return false;\r\n  } else {\r\n    // We can win/block! Grab one of the winning moves, and fill in the blank\r\n    markOneOfThese(shuffle(twos).pop());\r\n    return true;\r\n  }\r\n}\r\n\r\n// Check if there are: two OR one matching letters out of three, with one OR two blank spaces\r\nfunction isPotentialLineForming(board = buildBoard(), winningPattern, letter, blanksRequired) {\r\n  let blanks = 0;\r\n  let letters = 0;\r\n\r\n  for (let i = 0; i < winningPattern.length; i++) {\r\n    const cellContents = cells[winningPattern[i]].textContent;\r\n    if (cellContents === '') {\r\n      blanks++;\r\n    } else if (cellContents === letter) {\r\n      letters++;\r\n    }\r\n  }\r\n  if (blanksRequired === 1) {\r\n    return (blanks === 1 && letters === 2);\r\n  } else {\r\n    return (blanks === 2 && letters === 1);\r\n  }\r\n}\r\n\r\nfunction goInCentre() {\r\n  if (isEmpty(4)) {\r\n    markCell(4);\r\n    return true;\r\n  } else {\r\n    return false;\r\n  }\r\n}\r\n\r\n// Prevent losing due to this: http://www.wikihow.com/Win-at-Tic-Tac-Toe\r\nfunction coverOppositeCorners() {\r\n  if (!oppositeCornerDanger()) return false;\r\n\r\n  const middleEdges = shuffle([1, 3, 5, 7]);\r\n  markOneOfThese(middleEdges);\r\n  return true;\r\n}\r\n\r\nfunction oppositeCornerDanger() {\r\n  let blankCorners = 0, opponentCorners = 0;\r\n  const corners = [0, 2, 6, 8];\r\n  corners.forEach(corner => {\r\n    if (isEmpty(corner)) {\r\n      blankCorners++;\r\n    } else if (cells[corner].textContent === 'X') {\r\n      opponentCorners++;\r\n    }\r\n  });\r\n  return (blankCorners === 2 && opponentCorners === 2);\r\n}\r\n\r\n/* Stop user from being able to win across two edges.\r\n * e.g. in the following situation: \r\n * \r\n *    - - O\r\n *    X O O\r\n *    - - X\r\n * \r\n * The user could go in the bottom-left, and then we can't cover the win!\r\n * This is prevented by checking for two edges with one X in each.\r\n*/\r\nfunction coverAdjoiningEdges() {\r\n  const dangerousCorner = [0, 2, 6, 8].filter(corner => {\r\n    if (!isEmpty(corner)) return false;\r\n\r\n    const board = buildBoard();\r\n    // From a corner, can we see one other X in this column, and one in this row? If so, it must be blocked!\r\n    return (checkHorizontally(corner, board) && checkVertically(corner, board));\r\n  });\r\n\r\n  if (dangerousCorner.length === 0) {\r\n    return false;\r\n  } else {\r\n    markOneOfThese(dangerousCorner);\r\n    return true;\r\n  }\r\n}\r\n\r\nfunction checkHorizontally(corner, board) {\r\n  let cell1, cell2;\r\n  if (corner % 3 === 0) {  // left column\r\n    cell1 = corner + 1;\r\n    cell2 = corner + 2;\r\n  } else {                 // right column\r\n    cell1 = corner - 1;\r\n    cell2 = corner - 2;\r\n  }\r\n  return oneEmptyOneX(board, cell1, cell2);\r\n}\r\n\r\nfunction checkVertically(corner, board) {\r\n  let cell1, cell2;\r\n  if (corner < 3) {       // top row\r\n    cell1 = corner + 3;\r\n    cell2 = corner + 6;\r\n  } else {                 // bottom row\r\n    cell1 = corner - 3;\r\n    cell2 = corner - 6;\r\n  }\r\n  return oneEmptyOneX(board, cell1, cell2);\r\n}\r\n\r\nfunction oneEmptyOneX(board, cell1, cell2) {\r\n  return (board[cell1] === 'X' && board[cell2] === '' ||\r\n          board[cell1] === '' && board[cell2] === 'X');\r\n}\r\n\r\nfunction offensiveMove() {\r\n  // Look for a 'O' with two blank spaces, where we can make it one away from a win\r\n  const board = buildBoard();\r\n  const moves = wins.filter(win => isPotentialLineForming(board, win, 'O', 2));\r\n\r\n  if (moves.length === 0) {\r\n    // We can't go one the offensive on this turn\r\n    return false;\r\n  } else {\r\n    // We can! Grab one of the winning moves, and get one step closer to it\r\n    markOneOfThese(shuffle(moves).pop());\r\n    return true;\r\n  }\r\n}\r\n\r\nfunction goInRemaining() {\r\n  const corners = shuffle([0, 2, 6, 8]);\r\n  const remaining = shuffle([1, 3, 5, 7]);\r\n  markOneOfThese([...corners, ...remaining]);\r\n}\r\n\r\nfunction markOneOfThese(potentialMoves) {\r\n  for (let i = 0; i < potentialMoves.length; i++) {\r\n    if (isEmpty(potentialMoves[i])) {\r\n      markCell(potentialMoves[i]);\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction markCell(index) {\r\n  cells[index].textContent = 'O';\r\n  cells[index].classList.add('red');\r\n}\r\n\r\nfunction shuffle(arr) {\r\n  return arr.sort(() => 0.5 - Math.random());\r\n}\r\n"]}